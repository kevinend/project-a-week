#scope_export

add :: ( x: int, y: int ) -> (z: int) {
	return x + y;
}

GLOBAL :: #run add(3,4);

/*
	hmm there is a lot of indirection in here for whatever little benefit

	service locator pattern (not in OOP land)
	Three classes
		Audio
		Console-Audio
		Locator
			Audio *

	Mix and Match, i do like the idea of removing the managers and stuff that sounds like a good idea 
	to me honestly

	these are all member functions, 
	you can fake that with function pointers

	Audio {
		function1()
		function2()
		function3()
	}

	Console-Audio {
		using audio: Audio; if you don't need any info from there then you can use the APIs to do the thing
	}

	Service_Locator_Audio {
		(audio)


	}

	register_service()

	console_audio_play_sound
	console_audio_play
	and you could set that at compile-time i'd think
	then you could say

	audio.play_audio()
	audio.stop_audio()

	something.log_something();

	then you have some function that is like
	function1 :: ( Console_Audio, something else )
	but you have to pass that in and it isn't automatically passed into those functions


*/


// @Incomplete: Jai doesn't have an abstraction for reading from stdin yet...
/*
        #if OS == .WINDOWS {
            handle := GetStdHandle(STD_INPUT_HANDLE); // GetStdHandl
            bytes_read: u32;
            success := ReadFile(handle, buffer.data + input.count, cast(u32) (buffer.count - input.count), *bytes_read, null);

*/

// Powers of 2
// 2^1 = 2 
// 2^2 = 4
// 2^3 = 8
// 2^4 = 16
// 2^5 = 32
// 2^6 = 64, so if you dimension is six we only handle 64 bits worth of k-vectors
// 

// 2^3 
// 1-scalar
// 3-vectors
// 3-bivectors
// 1-trivector
// that is 8 total, what we going to do about it
// we ideally set the array equal to the max
// 2^3
// when you have e1, maybe we put the scalars at the end?
// Basis: e1 e2 e3
// Index: 0  1  2
// Integer Value: 1 2 4 
// 
// Possible values: scalar, e1, e2, e3, e1e2, e13, e23, e123
//  (1) scalar = 0???
//  (2) e1     = 1
//  (3) e2     = 2
//  (4) e3 	   = 4
//  (5) e1e2   = 3
//  (6) e1e3   = 5
//  (7) e2e3   = 6
//  (8) e1e2e3 = 7

// if we break it off into several different'types then the mapping is into a new type
// you would have the 1-vector
// 2-vector
// 3-vector
// etc...
// which you may or may not want for a representation
// really a k-vector can be distinguished from it's grade
// if we split them up then we don't need to create a new object
// well you would because you would be combining two of them

// Regressive Product -- Intersection/Factorization
// so in the book he says a one element regressive N element gives you a factorization
// of the one element in terms of the N element
//
// 
/*
	e1 regressive e1e2e3 by the common factor theorem
	1 + N = (1+N)-N = 1-element in terms of the second factor

		 e1      -e2       e3
		not(e1) not(-e2) not(e3)
	(e1 not(e1))e1 + (e1 not(-e2))e2 + (e1 not(e3))e3 // this comes out this way, shouldn't it come out this way in general???

	in general a 1 element can be a sum of of other 1 elements so it might be
	(e1+e2+e3) regressive N, which then decomposes into each part of the element, since some will be non-zero

	when John says "one-element" think the most general one element, not a single vector, a sum of 1-vectors

	regressive product is distributive over addition so this turns into something like
	(e1 ^ not(e1))e1 + (e2 ^ not(e2))e2 + (e3 ^ not(e3))e3

	there are a lot of terms in there that are zero, because you have to expand all of them but in the end this is what is returned
	in general there would be 9 terms and 6 of them would be zero

	########################################
	so what if you had to 'factor' a 2-element in a 3-space into a product of 1-elements (this is always the goal)?
	(e1e2 + e1e3 + e2e3) regressive (e1e2 + e1e3 + e2e3) == (2+2)-3 = (4)-3 = 1
	   Grade-2                        Grade-2

	   // like if you said to span this element, how would you do it?
	   // you'd have to distribute over the general two-element and take the regressive product

	   // say you have e1e2 and you say, give me the 1-span of it and the 1-cospan
	   // i would literally take the product with the general two element

	   e1e2 regressive (e1e2 + e1e3 + e2e3)
	   (e1e2 regressive e1e2)  + (e1e2 regressive e1e3) + (e1e2 regressive e2e3)
	    
	    e1e3:
	    1-span:   {e1,e3}
	    1-cospan: {e3,-e1}

		(e1e2 ^e1)e3 + (e1e2^e3)-e1 + (e1e2^e2)e3 + (e1e2^e3)e2
		// it has the terms you are looking for but it doesn't say these are the factors..
		// s1e1 + s2e2

		// we might just need to distribute and do the regressive product with the general element that gives us an
		// N+1 element and express it over that

		// i think it would go to zero if you tried to factor the same thing the same way



	   Grade of M = 2
	   1-span: Grade=1
	   1-copsan: (2-1) = 1

		// i'm thinking about the cospan wrong it is about the M-element, not the N-element
		// so how do you span this element?
		1-span:   {e1
	   	1-cospan: {

	what exactly would this look like?
	(e1e2 ^ not(e1e2))e1e2, this isn't a one element, so i got some of my facts mixed up here...

	// i think you have to distribute and then roll with the punches, i don't know another way to do it

*/

// here are the two options

K_Vector :: struct {
	grade: 			int;
	basis_elements: int; 	// this is a bit-vector (e1,e2,e3, e1
	coefficient:    float;  // some scalar multiple
}
// to get the basis_elements you need to look up the offset in the table and then can get the values
// if they are all k-vectors you can just put them in a list
// if they are separate you can't necessarily do that...hmm
// you don't need the offset lookups either



// n-choose-k
// build the list of offsets

choose :: (n: int, k: int) -> (value: int) {
	// example: choose(4,2) == (4*3)/(2*1) == 6
    if k == 0 return 1;
    return (n * choose(n-1, k-1)) / k;
}

// so the first step is to generate a list of the 1 elements then smash them
// together, if we end up representing bivectors and stuff differently this may all work out with using the span...
//

Vector2D :: struct { x: int; y: int; }

Vector_Type :: enum {
	 OneD;
	 TwoD;
	 ThreeD;
}

recurse :: ( x: int )  {
	if x == 0 { return; }
	print( "x == %\n", x );
	recurse( x-1 ); // tail recursion, the next instruction is outside of there so you don't see the stack
	print( "Tail Recursion Unwind\n" );
}

/*
	// so the default now is that we just read an identifier
	// but then we need to make a determination whether it is a keyword 
	// or if it is a basis symbol 

	// so an identifier can either be an identifier
	// lex
	// parse (set context)
	// checks the list to see if it is a basis element, otherwise it has to do a lookup (has to do it anyways)

	Dimension = 3;
	Basis_Symbols = [e1,e2,e3];
	Basis_Symbols = [x]; // expand to x1,x2,x3
	Basis_Symbols = [x,y,z]; 

	Deciding on how this should all work, i had a bunch of keywords but i don't think they are necessary
	The flow would be something like this.

	L1 = Whatever;
	L2 = Whatever;
	L3 = L1 + L2;
	L3; // this forces an eval

	For keywords:
	Dimension = 3; 				// parser recognizes this and immediately executes the Algebra_Context, generates the basis symbols e1,e2,e3
	Basis_Symbols = [e1,e2,e3]; // could default to G(R4) with basis symbols whatever
	// so that those symbols get recognized in the parser

	For identifiers we want to keep track whether they need re-evaluated or not
	which is just a simple flag.
*/

// op codes 
// so in his book
// lexer --> parser --> compile --> interpreter
// [string] --> [tokens] --> [AST] --> [ByteCode] --> [Output]
//  ^----------------------^ then some loop back here for some reason that I didn't understand


// good deal i think this is a good stopping place for now. Need to look at the parser
// maybe put this stuff in a lexer.jai file for grassmann
// think about file structure a bit more
/*
	grassmann.jai
	lexer.jai
	parser.jai
	eval.jai  

	// maybe three sets of files? i don't know man just hanging around!!!

*/

/*
	Executive decision, ultimately create font to create the glyphs
	Have a little window where you select the characters or some key mapping to pick from there

	Like Ctr+E or Alt+E for the exterior product and store that
	We are going to introduce symbols for now
	
	Going to use logical symbols for now
	<< e1^e2 is the left complement
	>> e1^e2 is the right complement
	regressive product is a compound symbol it is !^, it is the opposite of the exterior product

	(<< e1^e2^e3 !^ >> e1^e2) // definitely too messy for my liking but need to roll with it for now!
*/

/*
	What is the current problem?
	We want to introduce another step, compilation, prior to evaluation in our process.
	In the compilation step we MUST be able to issue an operand and have it result in a value
	So when you say something like:
		OpAdd 1 3 then you get the result 4 on that stack machine
		OpSub 1 4 then you get 3

	In our case our 'objects' will be different, they will be K-Elements but it's possible that the elements
	can't be directly summed
	OpAdd e1 e2 ; what does this resolve to? do we return a string and allocat this out again or something?
				  doesn't seem quite right

	We don't have a representation for a Multi-Element or define what addition is among a Multi-vector
	It is a pairwise assignment of coefficients but it isn't defined in the lexer or parser right now
	We also don't have the ability to recognize a symbol like e1^e2^e3 as a single element
	Ideally we'd like to be able to say e1e2e3 and have that be recognized as a single symbol
	We just represent everything as forms of basis-one elements

	Which doesn't necessarily seem wrong to me but we have to handle the multi-vectors on the other end somehow

	So i thought if we got the dimension and the list of basis one elements would could build the basis elements 
	
	e1
	e2
	e3
	e4
	e1e2
	e1e3 ...

	then when we are lexing we could recognize the elements
	if it isn't recognized as a single symbol then it is investigated further to separate out the component parts

	so you would have a table that is like this

		8, 16, 32, 64
		1      0
		e1	   1   (1 << 1)
		e2     2   (1 << 2)
		e3     3   (1 << 3)
		e1e2   4   (1 << 4)
		e1e3   5   (1 << 5)
		e2e3   6   (1 << 6)
		e1e2e3 7   (1 << 7)

		and these indices represented the index, so you have a field that is like basis-elements

		and you return the basis_elements as a bit field
			e1, e1e2
			the first bit and the 4th bit are set or something to that effect

			which ultimately represents a multivector which is the sum
			so give that element a grade of -1 (since it's grade is technically undefined)
			when you wedge a product over it, you'd have to generate a list of products
			^
		K-Element Multi-Grade-Element

		you'd have to issue instructions to take the K-Element over the first element and add instruction to the second
		^ LEFT RIGHT-FIRST // wherever you stored this
		^ LEFT RIGHT-SECOND // wherever you stored this
		+ a b
		// which if they are K-Elements then you get the summed result back
		// the thing that sucks if you need to track coefficients for all these bad boys, hmm
		// don't want to store a bunch of zeroes all over the place
		
		??? How do you perform the actual exterior/wedge product? 
		since before we just did an OR and that was simple but in this case if you have
		e1 and e2 and wedge them together then you don't get the correct result
		need to clear the bits
		and then it is not obvious that e1e2 ^ e1 is zero anymore

		can we use a combination of both ideas?
		it ultimately is a list of elements, not sure how else you could faithfully represent it

		so right now we punt on it but we would need a list of elements and their coefficients
		and their grades

		you probably end up with the same amount of space used and it literally is what it is
		you need to faithfully represent all these objects

		so instead of distribute the grassmann products you would have to build a thing

		e1 ^ (e1 + e2) this turns into a Multi-Element
			^
		  e1 +
		    e1 e2

		    ^
		  e1 Multi-Element which has a list of K-Element

		  then the result is itself a multi-element whose grade is degree 2
		  you need procedures that tell you whether it is a bivector or trivector
		  it is either K-Element 

		  a Multi-Element is either a K-Element or a linear combination of K-Elements of differing grades

		  Multi-Element: e1 e2
		  Multi-Element: e1^e1 + e1^e2 then this list collapses down to 0 + e1^e2

		 so you handle the distribution there instead of as a pass over the data

		 Multi-Element :: struct {
		 	#as using _kind: Ast_Node;
			elements: [] K_Element; // since these are all the same size we could just pool them
									// put them next to each other in memory
		 }

		 they actually won't exist in the parser, cause we will issue commands to turn them into these things
		 so they would exist in the interpreter when calculating final values

		 but we could introduce them into the 'grassmann-parser.exe' and see how that goes
		 since we don't have a working VM yet


		FROM DA BOOK:
		 Define the opcode and how it is encoded
		 Augment the compiler to emit the instruction
		 Update the VM to decode and execute the instruction
		 Rinse and Repeat

		 Stack-based VM since so it needs to have instructions to push and add and stuff like that


*/

// N = 4
// 1-4=  4
// 2-6= 12
// 3-4= 12
// 4-1=  4
//   32 iterations
// 4 * 15 = 60
// gray codes 
// 0, have to iterate over each of these
// 1, 
// 2, iterate through 2
// 3 iterate through 4
// 8 iterate through all 8
// 14 iterations, though you need to go through the call and manage the memory
// for this, but you do get the grades for free

// so if we allocate a buffer of 16 bits
// then we allocate the numbers 0 and 1
// then we iterate through that list
// and add a bit to the left and a bit to the right
// 00 01 10 11 // grade 2
// 000 001 010 001 011 101 110 can't keep track of grades this way like i thought
// forget that just do the pop count
// you can update the data as  you go
// 00 01 10 11 -> as you generate you lookup in the table and say these are the one elements

// This does a lot of work to build the basis elements but it does it once
// N = 4; total iterations = 32 to get grade
// N = 5; total iterations = 81 to get grade
// N = 6; total iterations = 193 to get grade

pop_count :: ( x: int ) -> ( count: int ) {

	count: int = 0;
	while x != 0 {
		count += 1;
		x &= x-1;
	}

	return count;
}

generate_basis_symbol :: ( element: int, grade: int, n: int, one_element_symbols: [] string ) -> ( symbol: string ) {

	builder: String_Builder;
	num_processed_basis_one_elements: int = 0;

	if grade == 0 {
		// this might not be the correct play when printing one-elements
		append( *builder, "1" );
	}
	else {
		// Iterate through each bit and lookup the corresponding basis symbol supplied by the user
		// This is slow when building the entire set of basis elements for the user however this code path
		// is traversed maybe once or twice during a run of the application so willing to put up with this for now.
		// Also if the dimension (N) starts creeping up then this gets even slower but it will for sure work, which
		// was not guaranteed with the other approaches I took.
		
		for i: 0..n-1 {
			if element & (1 << i) {
				append( *builder, one_element_symbols[i] );
				if num_processed_basis_one_elements < grade-1 { // in an expression like e1^e2 the number of exterior products is the grade-1
					append( *builder, "^" );
				}
				num_processed_basis_one_elements += 1;
			}
		}
	}

	// TODO: Leaking memory!!!
	symbol: string = builder_to_string( *builder );
	return symbol;
}

#load "stack.jai";

// we could store the multielement and then when we need it convert it to an AST at that point
// sounds a little wasteful because everytime you use that element it needs converted
// however, it would allow us to call 'build expression' or 'build ast' to inject in there
// but you would allocate L1 = L2;
// then you would use L2 I'd think you wouldn't use it all over the place
// and it is part of temporary memory, you could cache it if you wanted to 

// so that fixes the 'symbol-name' problem for now, just give a fixed permanent buffer
// then make a fixed buffer for the 

main :: () {

	// i think the lexer needs to include the type of the thing
	// he is tracking that this is a binary operator
	// or he is just returning null, then handling that up above

{
	value: int = 10;
	s := tprint( "Hello from outer space, my value is %\n", value );
	print( "%\n", s );
	print( "Type is %\n", type_of(s) );

	// so you can inject values
	// i think in the lexer we want on error to flag that the lexer ran into an error
	// and just be like 'hey unexpected character sequence"
	// in the parser you say something more explicit like unexpected token following identifier blah
	// which is the semantics vs the unrecognized symbols
}

{
	combination :: ( values: [] int, i: int, grade: int, element: int, n: int, k: int, output: *[..] int ) {
		
		if grade == k {
			array_add( output, element );
			return;
		}

		if i >= n {
			// combination never reached k and we ran out of elements, just return
			return;
		}

		include_first := element | (1 << i); // values[i];
		exclude_first := element;

		combination( values, i+1, grade+1, include_first, n, k, output );
		combination( values, i+1, grade,   exclude_first, n, k, output );
	}

	// set the basis elements [] Basis_Elements
	// allow that to be built into memory
	// then you can free and it just goes away

	values: [4] int = .[1,2,4,8];
	output: [..] int;
	n: int = 4;
	k: int = 1;

	// 
	// basis_element.grade  = grade;
	// basis_element.basis  = basis
	// basis_element.symbol --> could probably generate the symbol the symbol, pass in the grade so assign the grade
	// 
	//
	// we allocate the symbol buffer first then generate the symbol in here
	// generate_basis_elements
	//	 // this is n choose k with some additions to update the grade, and the basis symbol using our buffer
	// gosh this will be WAAY cleaner than before

	// allocate space for symbols
	// generate the basis elements, symbol, basis, and grade
	// create mappping record back and forth
	// set access to basis one symbols
	//
	// no more intermediate values with weights and iterating like 10 gd times
	// 

	combination( values, 0, 0, 0, n, 1, *output );
	combination( values, 0, 0, 0, n, 2, *output );
	combination( values, 0, 0, 0, n, 3, *output );
	combination( values, 0, 0, 0, n, 4, *output );



	print( "Output == %\n", output );
}

{

	Basis_Element_Builder :: struct {
		weight:     int;
		grade:      int;
		basis:      s64; // bits that point back to our bits-to-index table
	}

	pop_count :: ( x: int ) -> ( bit_count: int ) {

		// Implementation from here: https://en.wikichip.org/wiki/population_count
		bit_count: int = 0;
		while x != 0 {
			bit_count += 1;
			x = x & (x-1);
		}
		
		return bit_count;
	}

	calculate_weight :: ( element: s64, dimension: int, one_element_weights: [] int ) -> ( weight: int ) {

		weight: int = 0;
		for i: 0..dimension-1 {
			if element & (1 << i) {
				weight += one_element_weights[i];
			}
		}
		return weight;	
	}

	sort :: ( list: [] Basis_Element_Builder ) {
		// bubble sort
		for _: 0..list.count-1 {
			for i: 0..list.count-2 {
				if list[i+1].grade < list[i].grade {
					temp     := list[i];
					list[i]   = list[i+1];
					list[i+1] = temp;
				}
				else
				if list[i+1].grade == list[i].grade && list[i+1].weight > list[i].weight {
					temp     := list[i];
					list[i]   = list[i+1];
					list[i+1] = temp;
				}
			}
		}

		return;
	}


	

	elements: [4] s64 = .[1,2,4,8];
	one_element_weights:  [4] s64 = .[8,4,2,1]; // want e1 to have higher weight, then e2 to have second heighest weighting factor
	dimension := 4;

	basis_element_weights: [16] int;

	basis_elements: [16] Basis_Element_Builder;	
	
	basis_elements[0].grade  = 0;
	basis_elements[0].basis  = 0;

	for i: 1..15 {
		grade  := pop_count( i );
		weight := calculate_weight( i, dimension, one_element_weights );

		basis_elements[i].weight = weight;
		basis_elements[i].grade  = grade;
		basis_elements[i].basis  = i;
	}

	// so we have a builder to build the symbols in the order we want
	// Basis_Element_Builder (sort, iterate through the basis element, assign the grade and the symbol)
	//                       (iterate through it again to build the mapping table)
	// Basis_Element: grade, symbol
	// Basis_Bits_To_Index table

	for i: 0..basis_elements.count-1 {
		print( "(Grade,Weight,Basis) == (%,%,%)\n", basis_elements[i].grade, basis_elements[i].weight, basis_elements[i].basis );
	}
	print( "\n\n" );
	sort( basis_elements );
	for i: 0..basis_elements.count-1 {
		print( "(Grade,Weight,Basis) == (%,%,%)\n", basis_elements[i].grade, basis_elements[i].weight, basis_elements[i].basis );

	}

	// hmm i think i had this right in principal but something got mixed up in practice here
	//

	// this mapped okay it looks like e1e2 is the 5 the element that needs displayed
	// just type this into the code because you will forget
	bits_to_index: [16] s64;
	for i: 0..15 {
		index := basis_elements[i].basis;
		bits_to_index[index] = i;
	}

	// then iterate over the list again
	// and build the symbols for the whatever and you have your order bro
	// you want to do that symbol thing, where you allocate appropriate space for symbols or whatever
	// need to handle that as well

	print( "Bits to index == %\n", bits_to_index );

}

	// basis to index 
	// e1 = 1 
	// e2 = 2
	// e3 = 4
	// e4 = 8
	// e1e2 = 3 // however we want to render in the correct order
	// so we have to map this to the 'expression_order'
	//	[e1, e2, e1e2, e3, ... ]
	//            --> needs to point to index 4
	//  [e1,e2,e3,e4,e1e2]
	// we do that with weighting and grades

	// store the basis index in the table 
	// then iterate through it to build the reverse lookup table from bits to index



/*

	1  e1
	2  e2
	3  e12
	4  e3
	5  e13
	6  e23
	7  e123
	8  e4
	9  e14
	10
	11
	12
	13
	14
	15
*/

	// so you build the data structure that puts everything in order
	// it stores the grade, the symbol and the bits
	// then we iterate through our table and update the records in the bit mapping table back to us

	// grade, bits, symbol
	// other table just stores the index, when we do a sum we point back to here
	// that could work

	// we do a popcount for the grade and the weight, then do the sort
	//  e1 = 8
	//  e2 = 4
	//  e3 = 2
	//  e4 = 1
	//  e12 = 12
	//  e13 = 10
	//  e14 =  9
	//  e23 =  6
	//  e24 =  5 // these are the same 
	//  e34 =  3
	//  e123 = 14
	//  e124 = 13
	//  e134 = 11
	//  e234 =  7
	//  e1234 = 15

	//  then you have the original list that needs to point to this new ordered list

	// [bits] -->> [indices], have to build that mapping table


	// e1 = 1
	// e2 = 2
	// e3 = 4
	// e4 = 8
	//  e12 = 3
	//  e13 = 
	//  e14 =  9
	//  e23 =  6
	//  e24 =  5 // these are the same 
	//  e34 =  3
	//  e123 = 14
	//  e124 = 13
	//  e134 = 11
	//  e234 =  7
	//  e1234 = 15

	// if you sum these up can you multiply 

/*
	e1 = 1
	e2 = 2
	e3 = 3
	e4 = 4
	e1e2 = 3*2-1 = 5
	e1e3 = 4*2-1 = 7
	e1e4 = 5*2-1 = 9
	e2e3 = 5*2-1 = 11
	e2e4 = 
	e2e3
*/


	// mod 4 
	// mod 3 
	// mod 2
	// mod 1

	// weights are lookups but then we don't have the mapping, we just have the order we want to display in
	// 

	// sort by grade and by weight
	// if you build up the combinations

/* fucking recursion

	elements = 'e1,e2,e3,e4';
	k = 2;
	result = combinations( elements, 2 );

	combinations
	
	e1e2e3
	e1e2e4

	e1 e2 e3 e4
	e1 e2 e3 e4; e2 e3 then the queue would be reversed

	e1 e2 e3 e4
	e1 e2

	e3
	e4

	e1 e2 e3 e4a

	a 3 element list is a 2 element list + selecting 1 and a one element list is just the element and zero means you have the elements
	
	list of three elements, the smallest list of elements is a one element list, and you could return that

*/


{
	/*

	e1e2e3 e1e2e4  (need N-K) == (2), then the rest of the one elements
	
	e1e2e3 e1e2e4 // need to copy that pattern, they are like slices of the array
	e1e3e4
	e2e3e4

	K-N slice from the front
	how do you represent that programmatically dawg???

	left, right
	when do you adjust?

	do you add the number of subsets for a given index?
	something like e1, e2
	then the subsets like e2e3, e2e4, e3e4

	this is to build elements greater than n choose k where k < n and k > 2

	basically swap which queue you need to use for the operations
	 thinking about a double queue for this type of thing
	 N = 2
	 then you have a pointer to the 'active' queue
	 queue1: e1 e2
	 queue2: e2
	  ops:
	   D=e1
	   if queue1.num_elements == k-1 {
			D=e2
			combine to build an element
			add the dequeud element to queue2
		if is_empty(queue1) {
			active = queue2;
		}
		else
		if is_empty(queue2) {
			active = queue1
		}

		if active.num_elements == k { // able to build a k-element
		else {
			break;
		}
		// then you flip the active elements effectively
	}

	active:   *Queue;
	inactive: *Queue;
	queue1: fill with the one elements
	queue2: e2 e3
	active = queue1;
	while true {
		if active.num_elements < k {
			// unable to build a k-element
			break;			
		}

		while is_not_empty( active ) {
			element = dequeue( active ); // e1
			next    = dequeue( active ); // e2
			i := 2;
			while i 
			enqueue( inactive, next );

			build the element from eleme
		}
	}

	// could use a round-robin queue, since we know we will have fewer elements, that is a lot of copying and pasting though brother, it would be cheaper just to peak but just try to get it to work
		e1 e2 e3  dequeue several elements that you need and then re-queue them  e2, move this one down then dequeue and add them back to the queue e2 e3 e4, consume(e2), e3 e4 e3 e4
	Build Grade 2:
		Dequeue e1 --> anchor
		Dequeue e2 --> next
		Add e2 to inactive --> next_anchor
		build e1e2
		Dequeue e3
		build e1e3
		flip queue
		e2 e3
		build e2 e3
		it is empty so break
		got e1e2e3

		e1 e2 e3 e4 e5
		queue1: e3 e4 e5  e1e3, e1e4, e1e5
		queue2: e2 e3

		anchor: e1
		while active queue is not empty { // as you build the three elements in the 5 space you end up with  e1 e2 e3 e4 e5; e4 e5 e3
			next = dequeue( active );
			enqueue( next );
		}

		e1 e2 e3
		e1 e2 e4
		e1 e2 e5
		so it is n - (3) dequeue e1 e2 and combine those together, then iterate an element at a time
		then add e2 to the element list

		N - k = 2 that is the number of elements you have to grab up front

		// DOES THIS STRUCTURE WORK EVERYWHERE????
		N-K = 2  (3 elements in a 5 space), two elements + 1
		e1 e2 e3 e4 e5
		[    ] iterate through the rest of these
		  [    ] iterate through the rest of these
		       [   ] iterate through the rest of these

		e1 e2 e3
		e1 e2 e4
		e1 e2 e5
		e2 e3 e4
		e2 e4 e5
		e3 e4 e5

		e1 e2 e3 e4
		Grade2: (2 elements in a 4 space), 1 elements + 1
		[e1] --> e1e2, e1e3, e1e4
		  [e2]-->e2e3, e2e4
		    [e3]-->e3e4
		       [e4]-->nothing since you have a single element

		Grade 3: (3 elements in a 4 space), 1 elements + 2 [MATCH WHAT YOU DID WITH THE 5 ELEMENTS]
		e1 e2 e3 e4
		e1e2e3
		e1e3e4
		e2e3e4
		e1e2e4


		// maybe the queueing the right approach

		e1e2e3 e1e2e4; gosh seems like a stupid simple problem but my dumbass can't figure it out for some reason...FUCK!!!!
		
		

		e1 e2 e3 e4
		  [     ] e1e2e3
		     [     ]e1e3e4
		      [     ]e2e3e4 (now missing e1e2e4) hmmm...god damnit so close just need to figure out this one piece then all good
	*/
	

}

{
	Basis :: union {
		bits:  s64;
		index: s64;
	}

	basis: Basis;
	basis.bits = 1; // 1 2 which is 3 to an index
	print( "Basis.index == %\n", basis.index ); // this indexes into the basis elements, basis_bits_to_index, you want the mapping to be straightforward
	// but you would literally need them to index straight
	// e1 e2 e3 e4  e1e2
	// 1  2  3   4


	
}

{
	total: int = 0;
	x: int = 4;

	// this could work then
	if x == {
		case 4; { total += 4; } #through;
		case 3; { total += 3; } #through;
		case 2; { print( "Total == %\n", total ); }
	}
}

{
	Test :: enum {
		first;

		start_commands;
		command_1;
		command_2;
		end_commands;
	}

	cmd := Test.command_1;
	if cmd > Test.start_commands && cmd < Test.end_commands {
		print( "We fell inbetween here\n" );
	}

	cmd2 := Test.first;
	if cmd2 > Test.start_commands && cmd2 < Test.end_commands {
		print( "This shouldn't print shit\n" );
	}
	else {
		print( "This ran fine\n" );
	}
}

{
	parser_reported_error := true;
	while something := true {
		print( "This loop is running\n" );
		a: int = 5;
		b: int = 10;

		break something; // so that is one way to break out of the loop
	}

	if parser_reported_error == true {
		print( "Error detected\n" );
	}

}

{
	MAX_NUM_SYMBOLS 	   :: 8;
	SYMBOL_NAME_MAX_SIZE   :: 8;
	MAX_NUM_BASIS_ELEMENTS :: 64; 

	K_Element :: struct {
		coefficient: int;
		basis: s64;
	}

	Multi_Element :: #type [] K_Element;
	
	print( "The total size == %\n", MAX_NUM_SYMBOLS * SYMBOL_NAME_MAX_SIZE );

	Symbol :: struct {
		name:  string;
		value: Multi_Element;
	}

	names:  [MAX_NUM_SYMBOLS * SYMBOL_NAME_MAX_SIZE]   u8;
	values: [MAX_NUM_SYMBOLS * MAX_NUM_BASIS_ELEMENTS] K_Element;

	print( "Size of values == %\n", MAX_NUM_SYMBOLS * MAX_NUM_BASIS_ELEMENTS * size_of(K_Element) );

	num_symbols: int = 0;

	symbols: [MAX_NUM_SYMBOLS] Symbol;
	for i: 0..MAX_NUM_SYMBOLS-1 {
		symbols[i].name.data  = *names[0]  + (SYMBOL_NAME_MAX_SIZE * i);
		symbols[i].value.data = *values[0] + (MAX_NUM_BASIS_ELEMENTS * size_of(K_Element) * i);
	}

	// then when you lookup a symbol you traverse the names and look up the name
	// traverse the symbol table and lookup the name and then do the check which is in the same memory
	// do you collapse the buffer or do we just put it in the symbol? I guess we don't know at the time which symbol we want to update yet
	// hmm...

	for i: 0..MAX_NUM_SYMBOLS-1 {
		print( "Symbol pointer == %\n", symbols[i].name.data );
	}

	strings := string.["L1","origin","center", "centroid"];
	for i: 0..strings.count-1 {
		memcpy( symbols[i].name.data, strings[i].data, strings[i].count );
		symbols[i].name.count = strings[i].count;
		num_symbols += 1;
	}

	print( "Number of symbols == %\n", num_symbols );
	for i: 0..num_symbols-1 {
		print( "Symbol name == %\n", symbols[i].name );
	}
}

{
	x: *int = talloc( 5 * size_of(int) ); // 8 bytes * 5 is 40 total bytes
	print( "Context Temp storage usage %\n", context.temporary_storage.total_bytes_occupied	);
	for i: 0..4 {
		x[i] = i*10;
	}

	for i: 0..4 {
		print( "(%,%)\n", i, x[i] );
	}

	reset_temporary_storage();
	print( "Context Temp storage usage %\n", context.temporary_storage.total_bytes_occupied	);

	y: *int = talloc( size_of(int) );
	print( "Context Temp storage usage %\n", context.temporary_storage.total_bytes_occupied	);
}

	x := tprint( "Hello" );
	y := tprint( "World" );

	print( "Temporary storage uses % bytes\n", context.temporary_storage.total_bytes_occupied );
	reset_temporary_storage(); 
	print( "Temporary storage uses % bytes\n", context.temporary_storage.total_bytes_occupied );

	result: [..] int;
	result.allocator = temp;

	array_add( *result, 10 );
	array_add( *result, 11 );
	array_add( *result, 12 );
	array_add( *result, 13 );
	array_add( *result, 14 );
	array_add( *result, 15 );
	array_add( *result, 16 );
	array_add( *result, 17 );

	result2: [..] int;
	result2.allocator = temp;
	array_add( *result2, 100 );


	print( "Temporary storage uses % bytes\n", context.temporary_storage.total_bytes_occupied );
	reset_temporary_storage(); 
	print( "Temporary storage uses % bytes\n", context.temporary_storage.total_bytes_occupied );

{
	values: [5] int;
	for i: 0..values.count-1 {
		values[i] = -1;
	}

	// values[0] = 1;
	// values[1] = 2;
	values[4] = 5;
	end: int = 0;
	num_values: int = 0;

	for i: 0..values.count-1 {
		if values[i] > 0 {
			values[end] = values[i];
			num_values += 1;
			end += 1;
		}
	}

	print( "Values == %\n", values );

}

{
	// so now you can store the elements as a coefficient
	// this implements the flyweight pattern!
	//
	// so a k-element is a coefficient, element: int; which is just a lookup into the table
	// basis_element:
	// then you can take the basis_element exterior basis_element
	// k_element.basis ^ n_element.basis
	// something like that maybe?
	// then when you print you can do something like basis_elements[e1].symbol + basis_elements[e2].symbol
	// or something like that which is pretty cool

	power :: ( n: int, k: int ) -> ( value: int ) {
		value: int = 1;
		for i: 0..k-1 {
			value *= n;
		}

		return value;
	}
	bits: int;
	grade:  int;
	symbol: string;
	dimension: int = 3;
	one_element_symbols := string.["e1","e2","e3"];

	num_basis_elements: int = power( 2, dimension );

	for i: 0..num_basis_elements-1 {
		grade := pop_count(i);
		symbol = generate_basis_symbol( i, grade, dimension, one_element_symbols );
		print( "(i,grade,symbol) == (%,%,%)\n", i, grade, symbol );
	}
}

// should be able to apply the same idea with the k-span to generate all the elements
// something like this should work, so you allocate space to store all of these up front based on the dimension
{
	choose :: ( n: int, k: int ) -> ( value: int ) {
		// example: choose(4,2) == (4*3)/(2*1) == 6
		if k == 0 return 1;
		return (n * choose(n-1, k-1)) / k;
	}

	power :: ( n: int, k: int ) -> ( value: int ) {
		value: int = 1;
		for i: 0..k-1 {
			value *= n;
		}

		return value;
	}

	n: int = 3;
	// user supplies the list of basis symbols
	basis_symbols := string.["e1","e2","e3"];
	print( "Basis symbols count == %\n", basis_symbols.count );

	num_basis_elements: int = power( 2, n );
	print( "Num basis elements == %\n", num_basis_elements );

	Basis_Element :: struct {
		grade: int;
		symbol: string;
	}

	basis_elements: [] Basis_Element;
	basis_elements.data  = alloc( num_basis_elements * size_of(Basis_Element) );
	basis_elements.count = num_basis_elements;

	assert( basis_elements.data != null );

	basis_elements[0].grade = 1;
	basis_elements[0].symbol = "e1"; // didn't crash so that is good

	
	// then we populate this bitch with the values we create below
	// all we do is allocate a max of 2^6 which is 64 of these bad boys and use what we need so we don't have
	// to keep reallocating all the time
	
	// so our approach for the 'span' doesn't actually work
	// but we can do something a little bit more clever
	//
	// Grade N
	// Grade N-1
	// Grade 1
	// from the grade 1 we can easily build the Grade-1 elements
	// then the N-1 elements we iterate through the one elements and remove each 1-element one at a time
}

/*
	and you're like hey dude where is (3,11)?
	(3,7)
	(3,13)
	(3,14)

	but i think we can generate that rather easily

	and what do we have here?
	these are all the three elements, kablamy
	(7)
	(11)
	(13)
	(14)

	then from the three elements you want to store the two elements
*/

	return;
}

#scope_file
#import "Basic";
#import "File";
#import "Windows";
#import "String";

