/*
	This file implements a simple parser of Grassmann (exterior) algebra expressions.
	The structure of expressions handled by the parser are expressed as Backus-Naur Forms
	(BNF).

	As mentioned in the readme, Grassmann's products, especially the interior product of
	different graded elements is recursive in nature and cumbersome to expand by hand.
	This parser is written to allow an expansion phase to see the products fully expanded
	from an expression tree and then evaluated to return the final result.

	BNF for Grassmann expressions:
	 *The character R represents the 'Regressive' product. Don't want to get into unicode characters quite yet.
	  Eventually we will render those as logical and (U+2227) and or (U+2228) in unicode.

		expression 		::= <exterior-term>   [("+","-") <exterior-term]...
		exterior-term   ::= <exterior-factor> [("^","R") <exterior-factor>]...
		exterior-factor ::= ["-"] ( <basis-one-element> | <number> |  | "(" <expression> ")" )

	At the end of the week I did not make it as far as I hoped on this, the way she goes.
	The code compiles and runs without errors for the examples in main but there is a lot more functionality
	I intend to add to this one. Some of that functionality is listed below.

	NOTE:
	  Multiplication of basis elements by scalars is a tad clumsy.
	  You must specify multiplication using the exterior product. 3^e1 and not 3e1.
	  This isn't obvious until you try to parse the number 3 from 3e1 and use something like string-to-float
	  which e represents the exponent so it doesn't get read as a number with the additional e1 after it. It
	  gets read as 3e1 with the e interpreted as an exponent.

	  If your basis is not e1,e2,e3..eN then you could handle this differently but I don't want to restrict that
	  at this time so we are left with explicit exterior products.

	TODO:
	-- SORT THE LINEAR LIST AND DO SUMS THAT WAY INSTEAD OF ADDING UP
	--The way we encode the basis components currently is going to generate a bunch of incorrect signs
	  If we wedge e1^e3 then this is interpreted as e1^e3 but we need e3^e1 to be -e1^e3 if that is the order
	  of the call, it is too hot out here to even think, heading back inside
	--That print failed us in that one case and I'm not sure what went wrong on the last test case
	--Generate the span and cospans for elements (this would be super useful for expanding products)
	--Complement (left and right)
	--'Expand' functionality so that we can take the binary operator and return a new node that it replaces it, like two vectors becomes a bivector
	   Turn expressions of form e1^(e1+e2) into e1^e1 + e1^e2	
	--How do you free memory allocated to the string or string builder types built into the language?

	-- could do the flat list as well
	   e1 e1 e1 e2, so you sort then you sum
	   e1
	   e1, when it doesn't look like you, you add it to the list then you determine the next index, could do that as well
*/

/*
	The code, as written, cannot handle k-vectors that are sums of basis elements where
	the grade of the k-vector > 1. 

	So a bivector in G(R3) == e1e2 + e1e3 can not be expressed as a single k-vector, it is
	getting added to a list as [e1e2|e1e3] though we may technically need to handle it as a single
	element (in the case of a span or cospan operation). Therefore, changing up the approach a bit here
	and want to introduce the idea of using the higher bits of the 'basis_elements' bit-vector to represent elements of grade > 1.

	Right now we use the lower bits; bits 0,1, and 2 to represent say e1, e2 and e3 in G(R3) and say that a bivector like e1e2 has
	both the e1 and e2 bits set. As mentioned above, this is not a technically feasible approach going forward so we want to use
	more bits from the 'basis_elements' bit-vector to represent higher-graded objects directly and NOT as a mish-mash of bits of the
	1-vectors.

	There is a scheme on the k-vectors that actually works out nicely but requires the use of offsets based on the grade.

	Easiest to show as an example. Assume G(R3) though this should work up to dimension 6 which has 64 basis-elements and we would run out of bits with a 64-bit integer.
	bits:      [0,   1,   2,   3,   4,    5,    6, ...]
	values:    [1,   2,   4,   8,   16,  32,   64, ...] // powers of two

	elements:  [e1, e2,  e3,  e12, e13, e23, e123, ...]
			   <---------->   <------------> <--->
			   	 1-vectors      2-vectors     3-vectors
			   ^Grade1-offset ^Grade2-offset ^Grade3-offset ...

	Setting the 'bits' indicates which basis elements are included in the k-vector. bit-0 means e1 is present, bit-1 means e2 is present, etc..
	The 'values' represent the integer value of that bit being set. These values are only important for the basis-1 elements in this scheme.

	Conceptually we divide the 'elements' array into sections based on the grade of the elements.
	So in the case of G(R3) we have a 3-element section for the 1-elements, followed by a 3-element section for the 2-elements followed by a 1-element section for the 3-elements.

	Those offsets are calculated a single time once we declare the dimension of the space and then we need to determine the bit-index for the element we are interested in.
	e1 is at bit-index 0 relative to it's starting offset, e1e2 is at bit-index 0 relative to it's starting offset and e1e2e3 is at bit-index 0 relative to it's starting offset.

	How do you calculate the bit-index for an element? The formula is the following.
		Bit-Index = (Value(Set-1-Bits)/Grade)-1


	Look at e1e2 which is the 4th bit (3rd index) in our bit-vector.
	If you set the bits, e1 and e2 the value of that integer is 3, if you divide this by the grade of the resulting element, 2 in this case, and subtract 1, you get the following:
	 	Bit-Index = (Sum/Grade)-1 = 3/2 - 1 = 0
    So if you offset into the 64-bit integer into the 2-vector 'section' you can set the 4th (index 3) bit and know that represents the value e1e2.

    After this example you assume that you can just sum the 1-vectors values and get the correct index but that assumption is incorrect.

    Look at e1e3 which is the 5th bit (4th index) in our bit-vector.
    Value(e1) + Value(e3) = 5, which is the correct bit but the incorrect index (should be 4).
    Applying the formula from above gives you:
    	Bit-Index = (Sum/Grade)-1 = (5/2)-1 = 1
    Which is the correct index that needs set once you offset into the Grade-2 basis elements section.


*/

#scope_export

dimension: u8 = 0;
basis_one_elements: [..] string;
test_case: int = 0;

set_dimension :: ( N: u8 ) {

	assert( N > 0 );

	dimension = N;
	return;
}

set_basis_one_elements :: ( symbols: [] string ) {

	assert( symbols.count == dimension );
	assert( symbols.count > 0 );

	if basis_one_elements.count > 0 {
		array_reset( *basis_one_elements );
	}

	// copy the symbols over into our global symbol/basis elements table
	for symbol: symbols {
		array_add(*basis_one_elements, symbol );
	}

	return;
}

Node_Kind :: enum {
	K_Vector;
	Unary_Operator;  // complement (lcomp, rcomp)
	Binary_Operator; // exterior, regressive, interior
}

Expression_Node :: struct {
	kind: Node_Kind;
}

K_Vector_Node :: struct {

	// scalar, vector, bivector, trivector, ... , n-vector
	using _instance: Expression_Node;

	coefficient: float;
	grade: int;
	basis_components: s64; // bit field, we won't hit dimension 64 so I think we are okay here for now
}

Unary_Operator_Node :: struct {

	// left and right complement
	using _instance: Expression_Node;

	operation: string;
	operand:   *Expression_Node;
}

Binary_Operator_Node :: struct {

	// exterior, regressive, and interior products, +, -, *, / (division just handled for scalars now even though grassman division is supported)
	using _instance: Expression_Node;

	operation: u8;
	left_\operand: *Expression_Node;
	right_operand: *Expression_Node;
}

skip_spaces :: ( s: string ) -> ( cursor: string ) {
	cursor := s;
	while cursor && (cursor[0] == #char " " || cursor[0] == 9) { // horizontal tab
		advance( *cursor, 1 );
	}
	return cursor;
}

is_basis_one_element :: ( expression: string ) -> ( found_basis_element: bool, basis_element_index: s64 ) {

	string_compare :: ( s1: string, s2: string, n: int ) -> ( result: int, success: bool ) {

		// Invalid return values:
		// if the number of characters specified for comparison is larger than the number of characters in each string then return negative one and false

		// Valid return values:
		// zero means the strings are equal up to n bytes
		// negative one and a result of success means the strings are unequal and the character in the first string has a lesser value than the character in the second
		// positive one and a result of success means the strings are unequal and the character in the second string has a lesser value than the character in the first

		if s1.count < n || s2.count < n {
			return -1, false;
		}

		i: int = 0;
		while i < n && s1[i] == s2[i] {
			i += 1;
		}

		for i: 0..n-1 {
			if s1[i] == s2[i] { continue; }
			else
			if s1[i] < s2[i] { return -1, true; }
			else
			if s2[i] < s1[i] { return 1, true; }
		}

		return 0, true;
	}

	found_basis_element: bool = false;
	basis_element_index: s64  = -1;

	for i: 0..basis_one_elements.count-1 {
		if string_compare( expression, basis_one_elements[i], basis_one_elements[i].count ) == 0 {
			found_basis_element = true;
			basis_element_index = i;
			
			break;
		}
	}
	
	return found_basis_element, basis_element_index;
}

get_basis_one_element :: ( expression: string, basis_element_index: s64, is_negative: bool ) -> ( node: *Expression_Node, cursor: string ) {

	cursor := expression;

	basis_one_element := basis_one_elements[basis_element_index];

	node := New(K_Vector_Node);
	node.kind   	 = Node_Kind.K_Vector;
	node.grade  	 = 1; 
	node.basis_components |= (1 << basis_element_index);

	if is_negative { node.coefficient = -1; }
	else           { node.coefficient =  1; }
	
	advance( *cursor, basis_one_element.count );

	return cast(*Expression_Node)node, cursor;
}

parse_expression :: ( expression: string ) -> ( node: *Expression_Node, cursor: string ) {

	cursor := skip_spaces( expression );
	term: *Expression_Node = null;

	term, cursor = parse_exterior_term( cursor );
	cursor = skip_spaces( cursor );

	while cursor && (cursor[0] == #char "+" || cursor[0] == #char "-") {
		operation: u8;
		next_term: *Expression_Node;

		operation = cursor[0];
		advance( *cursor, 1 );

		next_term, cursor = parse_exterior_term( cursor );

		node	  		   := New(Binary_Operator_Node);
		node.kind  		   = Node_Kind.Binary_Operator;
		node.left_operand  = term;
		node.operation     = operation;
		node.right_operand = next_term;

		term = cast(*Expression_Node)node;
	}

	return term, cursor;
}

parse_exterior_term :: ( expression: string ) -> ( node: *Expression_Node, cursor: string ) {

	cursor := skip_spaces( expression );
	factor: *Expression_Node = null;

	factor, cursor = parse_exterior_factor( cursor );
	cursor = skip_spaces( cursor );

	while cursor && (cursor[0] == #char "^" || cursor[0] == #char "R") {
		operation: u8;
		next_factor: *Expression_Node;

		operation = cursor[0];
		advance( *cursor, 1 );

		next_factor, cursor = parse_exterior_factor( cursor );

		node	  		   := New(Binary_Operator_Node);
		node.kind  		   = Node_Kind.Binary_Operator;
		node.left_operand  = factor;
		node.operation     = operation;
		node.right_operand = next_factor;

		factor = cast(*Expression_Node)node;
	}

	return factor, cursor;

}

parse_exterior_factor :: ( expression: string ) -> ( node: *Expression_Node, cursor: string ) {

	cursor := skip_spaces( expression );
	node: *Expression_Node = null;

	factor_is_negative: bool = false;
	if cursor[0] == #char "-" {
		factor_is_negative = true;
		advance( *cursor, 1 );
	}

	is_basis_one_element, basis_element_index := is_basis_one_element( cursor );

	if is_basis_one_element {
		node, cursor = get_basis_one_element( cursor, basis_element_index, factor_is_negative );
	}
	else
	if is_digit( cursor[0] ) {
		success: bool;
		value: float;
		value, success, cursor = string_to_float( cursor );

		scalar_node := New(K_Vector_Node);
		scalar_node.kind   	    = Node_Kind.K_Vector;
		scalar_node.grade  	    = 0;

		if factor_is_negative { scalar_node.coefficient = -value; }
		else                  { scalar_node.coefficient =  value; }
		
		node = cast(*Expression_Node)scalar_node;
	}
	else
	if cursor[0] == #char "(" {
		advance( *cursor, 1 );
		node, cursor = parse_expression( cursor );

		cursor = skip_spaces( cursor );
		if cursor[0] == #char ")" {
			advance( *cursor, 1 );
		}
		else {
			print( "Error, unable to parse the expression, expected a terminating right parenthesis\n" );
			exit( -1 );
		}
	}
	else {
		print( "Error unable to parse the expression expected either a basis one element, number or subexpression wrapped in parens\n" );
		exit( -2 );
	}

	return node, cursor;
}

k_vector_to_string :: ( k_vector: *K_Vector_Node ) -> ( s: string ) {
	
	builder: String_Builder;
	num_processed_basis_elements: u8 = 0;

	// need a float to string to put the coefficient out front or a call to libc sprintf
	// punted on this and just used print statement for the coefficient then printed the string returned by this procedure.
	for i: 0..basis_one_elements.count-1 {
		if k_vector.basis_components & (1 << i) {
			append( *builder, basis_one_elements[i] );
			if num_processed_basis_elements < k_vector.grade-1 {
				// in expression like e1^e2 the number of exterior products is the grade minus 1
				append( *builder, "^" );
			}
			num_processed_basis_elements += 1;
		}
	}

	// MEMORY LEAK!!!
	// no idea how to free the builder in this language!
	s: string = builder_to_string( *builder );

	return s;
}

print_expression_tree :: ( node: *Expression_Node, indent: int = 0 ) {

	for i: 0..indent-1 {
		print( " " );
	}

	if node.kind == Node_Kind.K_Vector {
		
		k_vector := cast(*K_Vector_Node)node;
 
		if k_vector.grade > 0 {
			k_vector_as_string := k_vector_to_string( k_vector );
			print("%1%2\n", k_vector.coefficient, k_vector_as_string );
		}
		else {
			print( "%1\n", k_vector.coefficient );
		}
	}
	else 
	if node.kind == Node_Kind.Binary_Operator {
		binary_operator := cast(*Binary_Operator_Node)node;
		
		if binary_operator.operation == {
			case #char "^"; { print( "^\n" ); }
			case #char "R"; { print( "R\n" ); }
			case #char "+"; { print( "+\n" ); }
			case #char "-"; { print( "-\n" ); }
			case; print( "Unhandled operator case in print procedure.\n" );
		}

		print_expression_tree( binary_operator.left\_operand, indent + 2 );
		print_expression_tree( binary_operator.right_operand, indent + 2 );
	}

	return;
}

print_expression_from_expression_tree :: ( node: *Expression_Node ) {

	if node.kind == Node_Kind.K_Vector {	
		k_vector := cast(*K_Vector_Node)node;
 
		if k_vector.grade > 0 {
			k_vector_as_string := k_vector_to_string( k_vector );
			print( "%", k_vector_as_string );
		}
		else {
			print( "%", k_vector.coefficient );
		}
	}
	else 
	if node.kind == Node_Kind.Binary_Operator {
		binary_operator := cast(*Binary_Operator_Node)node;

		print_expression_from_expression_tree( binary_operator.left\_operand );

		if binary_operator.operation == {
			case #char "^"; { print( "^" ); }
			case #char "+"; { print( " + " ); }
			case #char "-"; { print( " - " ); }
			case; print( "Unhandled operator case in print procedure.\n" );
		}

		print_expression_from_expression_tree( binary_operator.right_operand );
	}

	return;
}

clone_k_vector_node :: ( k_vector_node: *K_Vector_Node ) -> ( cloned_node: *K_Vector_Node ) {

	cloned_node := New(K_Vector_Node);
	cloned_node.kind  			 = Node_Kind.K_Vector;
	cloned_node.grade 			 = k_vector_node.grade;
	cloned_node.coefficient 	 = k_vector_node.coefficient;
	cloned_node.basis_components = k_vector_node.basis_components;

	return cloned_node;
}

clone_unary_operator_node :: ( unary_operator_node: *Unary_Operator_Node ) -> ( cloned_node: *Unary_Operator_Node ) {

	cloned_node := New(Unary_Operator_Node);
	cloned_node.kind 	  = Node_Kind.Unary_Operator;
	cloned_node.operation = unary_operator_node.operation;
	cloned_node.operand   = clone_node( unary_operator_node.operand );

	return cloned_node;
}

clone_binary_operator_node :: ( binary_operator_node: *Binary_Operator_Node ) -> ( cloned_node: *Binary_Operator_Node ) {

	cloned_node := New(Binary_Operator_Node);
	cloned_node.kind 	  	= Node_Kind.Binary_Operator;
	cloned_node.operation 	= binary_operator_node.operation;
	cloned_node.left\_operand = clone_node( binary_operator_node.left\_operand );
	cloned_node.right_operand = clone_node( binary_operator_node.right_operand );

	return cloned_node;
}

clone_node :: ( node: *Expression_Node ) -> ( cloned_node: *Expression_Node ) {
		
	if node.kind == Node_Kind.K_Vector {
		return cast(*Expression_Node)clone_k_vector_node( cast(*K_Vector_Node)node );
	}
	else
	if node.kind == Node_Kind.Unary_Operator {
		return cast(*Expression_Node)clone_unary_operator_node( cast(*Unary_Operator_Node)node );
	}
	else
	if node.kind == Node_Kind.Binary_Operator {
		return cast(*Expression_Node)clone_binary_operator_node( cast(*Binary_Operator_Node)node );
	}
	else {
		print( "Unrecognized node kind found when cloning nodes\n" );
		return null;
	}
}

is_grassmann_operator :: ( op: u8 ) -> (bool) {
	if op == #char "^" || op == #char "R" {
		return true;
	}
	else {
		return false;
	}
}

distribute_grassmann_products :: ( node: *Expression_Node ) -> ( tree: *Expression_Node ) {

	// This procedure generates a whole new expression tree based on the initial expression tree
	// supplied by the caller. Ideally, we can update the tree in place, which is totally do-able
	// but until I have an initial implmentation up and working I think it is best to have
	// the 'expansion' or 'simplification' stages work on their own trees to ease debugging.
	 
	subtree: *Expression_Node;
	if node.kind != Node_Kind.Binary_Operator {
		subtree = clone_node( node );	
	}
	else {
		// Determine whether we need to distribute the grassmann products over any sums or differences.
		// The boolean values are introduced to reduce the level of nesting that happens if you don't 
		// do it that way (it was very hard to visually parse and a lot of duplicate 'clone the current node because
		// we don't need to distribute')

		binary_operator_node := cast(*Binary_Operator_Node)node;
		left\_operator: *Binary_Operator_Node = null;
		right_operator: *Binary_Operator_Node = null;

		distribute_over_left\_operand := false;
		distribute_over_right_operand := false;

		if is_grassmann_operator(binary_operator_node.operation) {
			if binary_operator_node.left_operand.kind == Node_Kind.Binary_Operator {
				left_operator = cast(*Binary_Operator_Node)binary_operator_node.left_operand;
				if left_operator.operation == #char "+" || left_operator.operation == #char "-" {
					distribute_over_left_operand = true;
				}
			}
			else if binary_operator_node.right_operand.kind == Node_Kind.Binary_Operator {
				right_operator = cast(*Binary_Operator_Node)binary_operator_node.right_operand;
				if right_operator.operation == #char "+" || right_operator.operation == #char "-" {
					distribute_over_right_operand = true;
				}	
			}
		}

		if distribute_over_left_operand {
			// distribute the argument on the right over the argument on the right
			distributive_operator    := binary_operator_node.operation;
			distribute_over_operator := left_operator.operation;

			new_binary_operator_node := New(Binary_Operator_Node);

			new_\left_node := New(Binary_Operator_Node);
			new_right_node := New(Binary_Operator_Node);

			new_left_node.kind           = Node_Kind.Binary_Operator;
			new_left_node.operation 	 = distributive_operator;
			new_left_node.left_operand   = clone_node( cast(*Expression_Node)left_operator.left_operand );
			new_left_node.right_operand  = clone_node( cast(*Expression_Node)binary_operator_node.right_operand );

			new_right_node.kind          = Node_Kind.Binary_Operator;
			new_right_node.operation 	 = distributive_operator;
			new_right_node.left_operand  = clone_node( cast(*Expression_Node) left_operator.right_operand ); 
			new_right_node.right_operand = clone_node( cast(*Expression_Node) binary_operator_node.right_operand );

			new_binary_operator_node.kind          = Node_Kind.Binary_Operator;
			new_binary_operator_node.operation     = distribute_over_operator; // + or -
			new_binary_operator_node.left\_operand = distribute_grassmann_products( cast(*Expression_Node)new_left\_node );
			new_binary_operator_node.right_operand = distribute_grassmann_products( cast(*Expression_Node)new_right_node );

			subtree = cast(*Expression_Node)new_binary_operator_node;
		}
		else
		if distribute_over_right_operand {
			// distribute the argument on the left over the argument on the right
			distributive_operator    := binary_operator_node.operation;
			distribute_over_operator := right_operator.operation;

			new_binary_operator_node := New(Binary_Operator_Node);

			new_\left_node := New(Binary_Operator_Node);
			new_right_node := New(Binary_Operator_Node);

			new_left_node.kind           = Node_Kind.Binary_Operator;
			new_left_node.operation 	 = distributive_operator;
			new_left_node.left_operand   = clone_node( cast(*Expression_Node)binary_operator_node.left_operand );
			new_left_node.right_operand  = clone_node( cast(*Expression_Node)right_operator.left_operand );

			new_right_node.kind          = Node_Kind.Binary_Operator;
			new_right_node.operation 	 = distributive_operator;
			new_right_node.left_operand  = clone_node( cast(*Expression_Node)binary_operator_node.left_operand );
			new_right_node.right_operand = clone_node( cast(*Expression_Node)right_operator.right_operand );
			
			new_binary_operator_node.kind          = Node_Kind.Binary_Operator;
			new_binary_operator_node.operation     = distribute_over_operator; // + or -
			new_binary_operator_node.left\_operand = distribute_grassmann_products( cast(*Expression_Node)new_left\_node );
			new_binary_operator_node.right_operand = distribute_grassmann_products( cast(*Expression_Node)new_right_node );

			subtree = cast(*Expression_Node)new_binary_operator_node;
		}
		else {
			subtree = clone_node( node );
		}
	}

	return subtree;
}

generate_k_span   :: ( element: *K_Vector_Node, k: int ) -> ( k_span: [..] *K_Vector_Node ) {
	
	// to generate a k-span you need the 1-span
	one_span: [..] int;
	for bit: 0..dimension-1 {
		if element.basis_components & (1 << bit) {
			array_add( *one_span, bit );
		}
	}

	k_span: [..] *K_Vector_Node;
	k_element     := New(K_Vector_Node);
	k_element.kind = Node_Kind.K_Vector;
	if k == 1 {
		for i: 0..one_span.count-1 {
			k_element.grade 	  = 1;
			k_element.coefficient = 1;
			k_element.basis_components |= (1 << one_span[i]);

			array_add( *k_span, clone_k_vector_node( k_element ) );

			k_element.basis_components &= 0; // reset/clear bits
		}
	}
	else {
		// build the set of k-elements (k-combinations) from the one-span.
		// this is O(N^3), probably a better way to do this!
		one_element := New(K_Vector_Node);
		for i: 0..one_span.count-1 {

			one_element.grade = 1;
			one_element.coefficient = 1;
			one_element.basis_components &= 0;
			one_element.basis_components |= (1 << one_span[i]);
			
			k_element := clone_k_vector_node( one_element );

			for j: i+1..one_span.count-1 {

				num_remaining_one_elements := one_span.count-j;
		
				if num_remaining_one_elements >= (k-1) {	
					s: int = 0;
					while k_element.grade != k {
						k_element.basis_components |= (1 << one_span[j+s]);
						k_element.grade += 1;
						s += 1;
					}

					array_add( *k_span, k_element );

					k_element = clone_k_vector_node( one_element );
				}
			}
		}
	}

	return k_span;
}

generate_k_cospan :: ( m_element: *K_Vector_Node, k_span: [..] *K_Vector_Node ) -> ( k_cospan: [..] *K_Vector_Node ) {

	anticommutative_coefficient :: ( left: *K_Vector_Node, right: *K_Vector_Node ) -> ( coefficient: int ) {
		
		// odd number of swaps between basis components requires a negation of the element's coefficient
		temp := clone_k_vector_node( right );
		num_swaps: int = 0;
		for < i: dimension-1..0 {
			if left.basis_components & (1 << i) {
				for j: 0..dimension-1 {
					if i == j { 
						temp.basis_components |= (1 << j);
						break;
					}
					else 
					if temp.basis_components & (1 << j) { 
						num_swaps += 1;
					}
				}
			}
		}

		free( temp );

		if num_swaps % 2 == 0 { return 1; }
		else { return -1; }
	}

	co_m_element :: ( m_element: *K_Vector_Node, k_element: *K_Vector_Node ) -> ( m_k_element: *K_Vector_Node ) {
		
		m_k_element := New(K_Vector_Node);
		m_k_element.kind  		= Node_Kind.K_Vector;
		m_k_element.grade 		= m_element.grade - k_element.grade;
		m_k_element.coefficient = 1;
		m_k_element.basis_components = m_element.basis_components ^ k_element.basis_components;

		m_k_element.coefficient *= anticommutative_coefficient( k_element, m_k_element );

		return m_k_element;
	}

	k_cospan: [..] *K_Vector_Node;
	for k_element: k_span {
		m_k_element := co_m_element( m_element, k_element );
		array_add( *k_cospan, m_k_element );
	}

	return k_cospan;
}

// result of simplify could be a binary operator node that is a sum or a k-vector so return an expression node

simplify :: ( node: *Expression_Node ) -> ( result: *Expression_Node ) {

	result: *Expression_Node;
	if node.kind != Node_Kind.Binary_Operator {	
		result = clone_node( node );
	}
	else {
		binary_operator_node := cast(*Binary_Operator_Node)node;
		binary_operator_node.left\_operand = cast(*Expression_Node)simplify( binary_operator_node.left\_operand );
		binary_operator_node.right_operand = cast(*Expression_Node)simplify( binary_operator_node.right_operand );

		if binary_operator_node.operation == #char "^" {		
			left  := cast(*K_Vector_Node)binary_operator_node.left\_operand;
			right := cast(*K_Vector_Node)binary_operator_node.right_operand;
			result = cast(*Expression_Node)exterior_product( left, right );	
		}
		else 
		if binary_operator_node.operation == #char "R" {
			// TODO: do you want to add the regressive product to this???
			print( "During simplify ran into a regressive product\n" );
			result = clone_node( node );
		}
		else {
			// sums or differences, just return
			print( "During simplify ran into a sum or difference\n" );
			result = clone_node( node );
		}
	}
	
	return result;
} 

// TODO: Combine this and 'distribute_grassmann_products' into a single 'expand' function
common_factor_theorem :: ( node: *Expression_Node ) -> ( tree: *Expression_Node ) {

	subtree: *Expression_Node;
	if node.kind != Node_Kind.Binary_Operator {
		subtree = clone_node( node );
	}
	else {
		// Determine whether we need to apply the common factor theorem to any regressive products.
		binary_operator_node := cast(*Binary_Operator_Node)node;
		if binary_operator_node.operation == #char "R" {
			left  := cast(*K_Vector_Node)simplify( binary_operator_node.left\_operand );
			right := cast(*K_Vector_Node)simplify( binary_operator_node.right_operand );

			if (left.grade + right.grade) < dimension {
				// regressive product is zero, don't bother expanding
				subtree = clone_node( node );
			}
			else {
				// generate the k-span and k-cospan of the right node.
				// k represents the grade of the element the left and right share in common.
				// Example:
				//	 N = 4
				//   A = e1^e3
				//   B = e2^e3^e4
				//   k = (Grade(A) + Grade(B)) - N == (2+3) - 4 == 5-4 = 1
				// 1-span:	 [e2,e3,e4]
				// 1-cospan: [e3e4, -e2e4, e2e3]

				k := (left.grade + right.grade) - dimension;
				k_span:	  [..] *K_Vector_Node = generate_k_span\ ( right, k );
				k_cospan: [..] *K_Vector_Node = generate_k_cospan( right, k_span );

				// build the regressive product subtrees from the k-span and k-cospan elements.
				// Example: using the span and cospan from the above example
				// regressive_product_subtrees = [subtree0, subtree1, subtree2, ...]
				//   where subtree0 =		R
				//						^     k-span[0]
				//				 	  L  k-cospan[0]

				regressive_product_subtrees: [..] *Binary_Operator_Node;
				for i: 0..k_span.count-1 {

					regressive_product_node := New(Binary_Operator_Node);
					regressive_product_node.kind = Node_Kind.Binary_Operator;
					regressive_product_node.operation = #char "R";
				
					exterior_product_node := New(Binary_Operator_Node);
					exterior_product_node.kind = Node_Kind.Binary_Operator;
					exterior_product_node.operation = #char "^";
					exterior_product_node.left\_operand = cast(*Expression_Node)clone_k_vector_node( left ); 
					exterior_product_node.right_operand = cast(*Expression_Node)k_cospan[i];

					regressive_product_node.left\_operand = cast(*Expression_Node)exterior_product_node;
					regressive_product_node.right_operand = cast(*Expression_Node)k_span[i];

					array_add( *regressive_product_subtrees, regressive_product_node );
				}

				// generate the new root node with the sums of the regressive product subtrees created above
				// Example: convert the subtrees into a tree 'sum', provided there is more than one subtree
				// regressive_product_subtrees: [subtree0, subtree1, subtree2, subtree3]
				//      		+
				// 		subtree0    +
				//      	subtree1 	+
				//        		subtree2 subtree3


				if regressive_product_subtrees.count == 1 {
					subtree = cast(*Expression_Node)regressive_product_subtrees[0];
				}
				else {

					root := New(Binary_Operator_Node);
					root.kind = Node_Kind.Binary_Operator;
					root.operation = #char "+";
					
					i: int = 0;
					current := root;
					while i < regressive_product_subtrees.count-2 { 
						current.left_operand = cast(*Expression_Node)regressive_product_subtrees[i];
						
						next := New(Binary_Operator_Node);
						next.kind 	   = Node_Kind.Binary_Operator;
						next.operation = #char "+";

						current.right_operand = cast(*Expression_Node)next;
						current = next;

						i += 1;
					}

					// the final sum needs handled outside the loop
					current.left\_operand = cast(*Expression_Node)regressive_product_subtrees[i];
					current.right_operand = cast(*Expression_Node)regressive_product_subtrees[i+1];

					subtree = cast(*Expression_Node)root;
				}
			}
		}
		else {
			// binary operator node is not a regressive product, just clone the node and return it
			subtree = clone_node( node );
		}
	}

	return subtree;
}
	
flatten :: ( subtree: *Expression_Node ) -> ( operators: [..] u8, elements: [..] K_Vector_Node ) {
	
	// In-order traversal of the distributed expression tree.
	// Once we have the flattened list of operators (sums/differences/grassmann products) and elements (1-vector/basis 1 elements)
	// we need to evaluate the possible cases of our tree.
	//
	
	flatten_helper :: ( node: *Expression_Node, operators: *[..] u8, elements: *[..] K_Vector_Node ) {

		success: bool;
		
		if node.kind == Node_Kind.K_Vector {
			k_vector_node := cast(*K_Vector_Node)node;
			
			k_vector: K_Vector_Node;
			k_vector.kind 		 	  = Node_Kind.K_Vector;
			k_vector.coefficient 	  = k_vector_node.coefficient;
			k_vector.grade       	  = k_vector_node.grade;
			k_vector.basis_components = k_vector_node.basis_components;

			array_add( elements, k_vector );
		}
		else
		if node.kind == Node_Kind.Binary_Operator {
			binary_operator_node := cast(*Binary_Operator_Node)node;
			flatten_helper( binary_operator_node.left\_operand, operators, elements );

			array_add( operators, binary_operator_node.operation );

			flatten_helper( binary_operator_node.right_operand, operators, elements );
		}
	}

	operators: [..] u8;
	elements:  [..] K_Vector_Node;

	flatten_helper( subtree, *operators, *elements );

	return operators, elements;
}

// THIS IS RETURNING A POINTER TO A K-ELEMENT BECAUSE OF SIMPLIFY, we may not want to do this for eval!!!
// or do we want simplify to return the list then flatten is to take the products and sort them or something
// maybe we replace eval then we just traverse the tree and if the operation is a sum then we add it to the list or something
// i am not exactly sure what we want to do here yet
exterior_product :: ( lvalue: K_Vector_Node, rvalue: K_Vector_Node ) -> ( result: *K_Vector_Node ) {

		result := New(K_Vector_Node);
		result.kind = Node_Kind.K_Vector;

		if (lvalue.grade + rvalue.grade) > dimension {
			result.grade = 0;
			result.basis_components = 0;
			result.coefficient = 0;
		}
		else
		if lvalue.grade == 0 || rvalue.grade == 0 {
			result.grade       	    = lvalue.grade + rvalue.grade;
			result.basis_components = lvalue.basis_components | rvalue.basis_components;
			result.coefficient 	    = lvalue.coefficient * rvalue.coefficient;	
		}
		else
		if (lvalue.basis_components & rvalue.basis_components) > 0 {
			// k-vector arguments share at least one common basis vector and exterior product is zero
			result.grade 			= 0;
			result.basis_components = 0;
			result.coefficient 	    = 0;	
		}
		else {
			// Take the exterior product between the elements and handle the anticommutativity property of the grassmann product.
			// For every bit (basis one element) in the LEFT argument
			//	Start at right-most bit in the LEFT arg
			//  Find it's place in the RIGHT arg and set that bit.
			//	Anytime you cross over a bit in the RIGHT that is set, then you have swapped the elements.
			// Rinse and repeat for every other bit in the LEFT.
			//
			// If after completing this process we have swapped an odd number of times then we negate the final product.

			result.grade 		= lvalue.grade + rvalue.grade;
			result.coefficient  = lvalue.coefficient * rvalue.coefficient;

			result.basis_components = rvalue.basis_components;
			num_swaps: int = 0;
			for < i: dimension-1..0 {
				// Start from the rightmost bit in the left argument and determine which bits are set
				if lvalue.basis_components & (1 << i) {
					// Bit in the left argument is set, iterate from the leftmost bit in the right argument
					// and everytime the a bit is set increment the swap counter.
					// When we get to the location of the bit from the left in the location on the right, set the bit in the result, stop the 'swap' loop and start over with any other bits from the left.
					for j: 0..dimension-1 {
						if j == i {
							result.basis_components |= (1 << j);
							break;
						}
						else
						if result.basis_components & (1 << j) {
							num_swaps += 1;	
						}
					}
				}
			}

			if num_swaps % 2 != 0 { result.coefficient *= -1; }	
		}

		return result;
}

regressive_product :: ( lvalue: K_Vector_Node, rvalue: K_Vector_Node ) -> ( result: K_Vector_Node ) {

	result: K_Vector_Node;
	result.kind = Node_Kind.K_Vector;

	// The way this is currently written we always expand the RIGHT operand in a regressive product
	// then we take the EXTERIOR product between the original LEFT operand and the k-cospan RIGHT argument.
	// so we want to check is the LEFT argument of this subtree
	//
	// so to make this allow expansion of the left or right we need to check whether one argument

	if lvalue.grade < dimension && rvalue.grade < dimension {
		// After applying the common factor theorem, to either the right or left argument neither expansion created an N-element
		// so the product is zero.
		result.grade = 0;
		result.basis_components = 0;
		result.coefficient = 0;
	}
	else
	if lvalue.grade == dimension {
		// return the right-operand 
		result.grade 	   		= rvalue.grade;
		result.coefficient 		= rvalue.coefficient * lvalue.coefficient;
		result.basis_components = rvalue.basis_components;
	}
	else 
	if rvalue.grade == dimension {
		// return the left-operand
		result.grade 			= lvalue.grade;
		result.coefficient 		= lvalue.coefficient * rvalue.coefficient;
		result.basis_components = rvalue.basis_components; 
	}
	else {
		print( "In regressive product, our if/else conditions don't handle the current case, investigate\n" );
		result.grade = 0;
		result.basis_components = 0;
		result.coefficient = 0;
	}

	return result;
}

// instead of flatten, we have eval that allows you to evaluate from certain points in the tree
// so flatten traverses the entire tree but what eval should do is generate a tree that is just sums
// then if we have sums or whatever, then you don't necessarily have to flatten the tree if you don't want to
// you could kind of just leave it and generate the expression if you want to...decisions, decisions
// i really like the idea of eval 
// if you can resolve the sum, go ahead, if you can't then you can't, 
// or difference, then you can flatten and remove sums if need be
// 
eval2 :: ( operators: [] u8, elements: [] K_Vector_Node ) -> ( k_vectors: [..] K_Vector_Node ) {

		bubble_sort :: ( k_vectors: *[] K_Vector_Node ) {

		swap: bool     = false;
		for _: 0..k_vectors.count-1 {
			for i: 0..k_vectors.count-2 {
				if 	(<<k_vectors)[i+1].grade <= (<<k_vectors)[i].grade && 
			   		(<<k_vectors)[i+1].basis_components < (<<k_vectors)[i].basis_components {

					temp     	  	          := (<<k_vectors)[i];
					(<<k_vectors)[i]   = (<<k_vectors)[i+1];
					(<<k_vectors)[i+1] = temp;

					swap = true;
				}
			}

			if !swap { return; }
			swap = false;
		}
	}

	// Possible cases with the operators and elements:
	//	1. No operators need applied, return the element
	//		operators: []
	//		elements : [k-vector]
	//
	// 2. Grassmann products only; apply the operators to build the resulting single k-vector element
	//      operators: [^,^,^..] 
	//		elements:  [k-vector1, k-vector2, k-vector3...]
	//
	// 3. Sums and difference only; sort the elements so k-vectors of same basis components can be summed
	//		operators: [+,-,+]
	//		elements:  [e1,e2,e1]
	//
	//		sort( elements );
	//
	//		operators: [+,+,+] 
	//		elements: [e1,e1,-e2]
	//
	// 4. Grassmann products and sums/differences; resolve grassmann products, sort then sum elements.
	//		operators: [^^+^]
	//		elements:  [e1,e2,e3,e2,e3]
	//
	//		Post grassmann eval:
	//		operators: [+]
	//		elements:  [e1e2e3,e2e3]
	//
	// 		sort( elements );
	//		
	//		operators: [+]
	//		elements: [e2e3,e1e2e3]
	//
	//		Final Result:
	//		e2^e3 + e1^e2^e3

  
  	// When this is a single element this process is wasteful.
  	// We 'dequeue' the element and 'enqueue' it twice before returning it as the result.
  	// However, it does provide a nice flat structure to the code.

  	success: bool;

 	lvalue: K_Vector_Node;
 	rvalue: K_Vector_Node;
 	op: u8;

 	products: [..] K_Vector_Node; // if single element think 1^e1 == e1 or N \/ e1 = e1

	lvalue = elements[0];
	for i: 0..operators.count-1 {
		op = operators[i];
		rvalue = elements[i+1];
		if op == #char "^" { 
			lvalue = exterior_product( lvalue, rvalue ); 
		}
		else
		if op == #char "R" {
			lvalue = regressive_product( lvalue, rvalue );
		}
		else
		if op == #char "+" || op == #char "-" {
			if op == #char "-" { rvalue.coefficient *= -1; }
			array_add( *products, lvalue );
			lvalue = rvalue;
		}
	}
	array_add( *products, lvalue );

	bubble_sort( *products );

	results: [..] K_Vector_Node;

	lvalue = products[0];
	for i: 1..products.count-1 {
		rvalue = products[i];
		if lvalue.basis_components == rvalue.basis_components {
			lvalue.coefficient += rvalue.coefficient;
		}
		else {
			array_add( *results, lvalue );
			lvalue = rvalue;
		}
	}
	array_add( *results, lvalue );

	return results;
}

// NEED THIS FOR THE UNARY COMPLEMENT OPERATOR, LEAVE UNTOUCHED FOR NOW
complement :: ( k_vector: K_Vector_Node, N: int ) -> ( n_k_vector: K_Vector_Node ) {
	
	// This is the RIGHT complement!!!
	// The N-element is dependent on the user-supplied value of N.
	// Typically, N will be set to the dimension of the space, however when generating a span or cospan of an element
	// we can use this same logic by using the M-element to be the N-element for purposes of the operation.

	n_element: K_Vector_Node;
	n_element.kind        = Node_Kind.K_Vector;
	n_element.grade 	  = N;
	n_element.coefficient = 1;
	for i: 0..N-1 {
		n_element.basis_components |= (1 << i);
	}

	n_k_vector: K_Vector_Node;
	n_k_vector.kind             =  Node_Kind.K_Vector;
	n_k_vector.grade 	    	=  N - k_vector.grade;
	n_k_vector.coefficient 	 	=  k_vector.coefficient;
	n_k_vector.basis_components =  k_vector.basis_components ^ n_element.basis_components; // XOR


	// The exterior product of (k)-Vector and an (N-k)-Vector is a scalar multiple of the (N)-Vector.
	// To determine the number of swaps and therefore the sign of the coefficient of the complement 
	// we take the exterior product between the (k)-Vector and (N-K)-Vector and generate the N-vector.
	// If the number of swaps is odd then we negate the coefficient on the complement (n-k)-Vector.

	n_vector: K_Vector_Node = n_k_vector;
	
	num_swaps: int = 0;
	for < i: N-1..0 {
		// Start from the rightmost bit in the left argument and determine which bits are set
		if k_vector.basis_components & (1 << i) {
			// Bit in the left argument is set, iterate from the leftmost bit in the right argument
			// and everytime the a bit is set increment the swap counter.
			// When we get to the location of the bit from the left in the location on the right, set the bit in the result, stop the 'swap' loop and start over with any other bits from the left.
			for j: 0..dimension-1 {
				if j == i {
					n_vector.basis_components |= (1 << j);
					break;
				}
				else
				if n_vector.basis_components & (1 << j) {
					num_swaps += 1;	
				}
			}
		}
	}

	if num_swaps % 2 != 0 { n_k_vector.coefficient *= -1; }	

	return n_k_vector;
}

test :: ( 
	 dimension: u8
	,basis: [] string
	,expression: string
	,should_print_expression_tree_post_parsing: 	 bool = true
	,should_print_expression_tree_post_distribution: bool = true
	,should_print_expression_tree_post_common_factor_theorem:   bool = true
	,should_print_expression_tree_post_grassmann_operator_eval: bool = true
) {

	test_case += 1;

	set_dimension( N = dimension );
	set_basis_one_elements( basis );

	print( "Test case %:\n", test_case );
	print( "Original Expression: %\n", expression );

	expression_tree: *Expression_Node = parse_expression( expression );
	if should_print_expression_tree_post_parsing {
		print( "Initial expression tree\n" );
		print_expression_tree( expression_tree );
		print( "\n" );
	}

	expression_tree_post_distribution := distribute_grassmann_products( expression_tree );
	if should_print_expression_tree_post_distribution {
		print( "Expression tree post distribution of grassmann products:\n" );
		print_expression_tree( expression_tree_post_distribution );
	}

	expression_tree_post_common_factor_theorem := common_factor_theorem( expression_tree_post_distribution );
	if should_print_expression_tree_post_common_factor_theorem {
		print( "Expression tree post application of the common factor theorem:\n" );
		print_expression_tree( expression_tree_post_common_factor_theorem );
	}

	// THE FOLLOWING FLATTEN AND EVAL ARE RUNNING OVER THE TREE 'POST-DISTRIBUTION' NOT AFTER THE CFT
	// This is intentional for now until I can test out the CFT code

	operators, elements := flatten( expression_tree_post_common_factor_theorem );

	results := eval2( operators, elements );

	// print_simplified_expression()
	for result: results {
		k_vector_as_string := k_vector_to_string( *result );
		print( "%1%2 ", result.coefficient, k_vector_as_string );
	}
	print( "\n" );

	return;
}




main :: () {

/*
{
	set_dimension( 3 );
	set_basis_one_elements( string.["e1","e2","e3"] );

	e1: K_Vector_Node;
	e1.basis_components = 1;
	e1.grade = 1;
	e1.coefficient = 1;

	e2e3 := complement( e1, N=dimension );
	print( "Debugger\n" );

}

{
	set_dimension( 3 );
	set_basis_one_elements( string.["e1","e2","e3"] );

	e2: K_Vector_Node;
	e2.basis_components = 2;
	e2.grade = 1;
	e2.coefficient = 1;

	e1e3 := complement( e2, N = dimension );
	print( "Debugger\n" );
}

{

	set_dimension( 3 );
	set_basis_one_elements( string.["e1","e2","e3"] );

	e1e3: K_Vector_Node;
	e1e3.basis_components = 5;
	e1e3.grade = 2;
	e1e3.coefficient = 1;

	e2 := complement( e1e3, N = dimension );
	print( "Debugger\n" );

}

{

	set_dimension( 2 );
	set_basis_one_elements( string.["e1","e2"] );

	e2: K_Vector_Node;
	e2.basis_components = 2;
	e2.grade = 1;
	e2.coefficient = 1;

	e1 := complement( e2, N = dimension );
	print( "Debugger\n" );

}

{

	set_dimension( 2 );
	set_basis_one_elements( string.["e1","e2"] );

	_e1: K_Vector_Node;
	_e1.basis_components = 1;
	_e1.grade = 1;
	_e1.coefficient = 1;

	_e2 := complement( _e1, N = dimension );
	print( "Debugger\n" );

}

{

	set_dimension( 4 );
	set_basis_one_elements( string.["e1","e2","e3","e4"] );

	e12: K_Vector_Node;
	e12.basis_components = 3;
	e12.grade = 2;
	e12.coefficient = 1;

	e34 := complement( e12, N = dimension );
	print( "Debugger\n" );
}

{

	set_dimension( 4 );
	set_basis_one_elements( string.["e1","e2","e3","e4"] );

	e1: K_Vector_Node;
	e1.basis_components = 1;
	e1.grade = 1;
	e1.coefficient = 1;

	e234 := complement( e1, N = dimension );
	print( "Debugger\n" );
}

{

	set_dimension( 4 );
	set_basis_one_elements( string.["e1","e2","e3","e4"] );

	e2: K_Vector_Node;
	e2.basis_components = 2;
	e2.grade = 1;
	e2.coefficient = 1;

	e134 := complement( e2, N = dimension );
	print( "Debugger\n" );
}

*/

// THE FOLLOWING TWO SECTIONS ARE THE GENERATE-K-SPAN and GENERATE-K-COSPAN TESTS

/*
{
	k_vector := New(K_Vector_Node);
	k_vector.grade = 4;
	for i: 0..3 {
		k_vector.basis_components |= (1 << i);
	}
	print( "Basis components == %\n", k_vector.basis_components );

	m_k_cospan: [..] K_Vector_Node;
	m_k_element: K_Vector_Node;

	k_span := generate_k_span( k_vector, 1 );
	for i: 0..k_span.count-1 {
		print( "(Grade,Coefficient,Basis-Components) == (%,%,%)\n", k_span[i].grade, k_span[i].coefficient, k_span[i].basis_components );
	}
	print( "\n" );

	k_span = generate_k_span( k_vector, 2);
	for i: 0..k_span.count-1 {
		print( "(Grade,Coefficient,Basis-Components) == (%,%,%)\n", k_span[i].grade, k_span[i].coefficient, k_span[i].basis_components );
	}
	print( "\n" );
	

	k_span = generate_k_span( k_vector, 3); // this doesn't work in a 4-space,
	for i: 0..k_span.count-1 {
		print( "(Grade,Coefficient,Basis-Components) == (%,%,%)\n", k_span[i].grade, k_span[i].coefficient, k_span[i].basis_components );
	}
	print( "\n" );

	// 1 2 4 8 
	// 

	print( "This is for the 4 span of the element\n" );
	k_span = generate_k_span( k_vector, 4);
	for i: 0..k_span.count-1 {
		print( "(Grade,Coefficient,Basis-Components) == (%,%,%)\n", k_span[i].grade, k_span[i].coefficient, k_span[i].basis_components );
	}
	print( "\n" );
}

{
	m_element := New(K_Vector_Node);
	m_element.grade = 3;
	m_element.basis_components |= (1 << 0); // e1
	m_element.basis_components |= (1 << 2); // e3
	m_element.basis_components |= (1 << 3); // e4

	k_span   := generate_k_span( m_element, 1 );
	k_cospan := generate_k_cospan( m_element, k_span );

	print( "SPAN:\n" );
	for i: 0..k_span.count-1 {
		print( "(Grade,Coefficient,Basis-Components) == (%,%,%)\n", k_span[i].grade, k_span[i].coefficient, k_span[i].basis_components );
	}
	print( "\n" );

	// the number of swaps doesn't look right, but we need to take a mental break i can feel it, time for a walk and X
	print( "COSPAN:\n" );
	for i: 0..k_span.count-1 {
		print( "(Grade,Coefficient,Basis-Components) == (%,%,%)\n", k_cospan[i].grade, k_cospan[i].coefficient, k_cospan[i].basis_components );
	}
	print( "\n" );
}
*/

// THE FOLLOWING SECTIONS ARE FOR TESTING THE EXPANSION OF THE COMMON FACTOR THEOREM
{
	// the problem is in partial eval, i need to reevaluate how i want that to work at all
	// we should just call eval and let the chips lie where they may
	// you just happen to eval from that point
	// eval shouldn't come across any regressive products at that point in the tree, so it SHOULD be safe!!!

	test( dimension = 4, basis = string.["e1","e2","e3","e4"], expression = "(e2^e3)R(e1^e3^e4)" );	
}

// THIS IS THE ORIGINAL TESTING OF THE TOP-LEVEL FUNCTIONS
/*
	test( dimension = 5, basis = string.["e1","e2","e3","e4","e5"], expression = "(e1^e2^e3)+(e2^e3^e4)+(e1^e4^e5)" );

	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "3" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "3^3" ); // the sum might be broken, that's okay though
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "e1^e2" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "3+3" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "3+3+3" );
	
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "e2^e1" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "e1^(e1+e2)" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "(e1+e2)^(e1+e2)" );

	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "e1 + e2 + e1" );

	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "3+e1+3" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "e1^(e1+e2+e3)" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "(e1+e2)^(e1+e2+e3)" );

	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "3" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "-3" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "3^5" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "-3^-5" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "3^e1" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "-3^e1" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "e1^e1" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "e1^e2" );	
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "(e1^e2)" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "(e1^e2)^e3" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "e1^e2^e3" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "(3^e1)^(4^e2)" );	
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "e1+e1" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "e1-e1" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "e1+e2+e1" ); 

	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "e1-2^e1" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "e1^e2+e1" );
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "e1^(e1+e2)" ); 
	test( dimension = 3, basis = string.["e1","e2","e3"], expression = "(e1+e3)^(e1+e2)" ); 
*/

	return;
}

#scope_file
#import "Basic";
